{"version":3,"file":"accessor-log-proxy.modern.js","sources":["../src/isPlainObject.ts","../src/accessor-log-proxy.ts"],"sourcesContent":["const class2type = {};\nconst toString = class2type.toString;\nconst getProto = Object.getPrototypeOf;\nconst hasOwn = class2type.hasOwnProperty;\nconst fnToString = hasOwn.toString;\nconst ObjectFunctionString = fnToString.call(Object);\n\n/**\n * is plain object, return true\n * if the obj is Map, Set ..., return false\n * @param obj\n */\nexport function isPlainObject(obj: unknown): obj is {} {\n    // Detect obvious negatives\n    // Use toString instead of jQuery.type to catch host objects\n    if (!obj || toString.call(obj) !== \"[object Object]\") {\n        return false;\n    }\n\n    const proto = getProto(obj);\n\n    // Objects with no prototype (e.g., `Object.create( null )`) are plain\n    if (!proto) {\n        return true;\n    }\n\n    // Objects with prototype are plain iff they were constructed by a global Object function\n    const Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\n    return typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\n}\n","import { isPlainObject } from \"./isPlainObject\";\n\n/**\n * create proxy object for `object`\n * @param object\n */\nexport const createProxy = <T extends object>(object: T): { proxyObject: T, accessSet: Set<string> } => {\n    const accessSet = new Set<string>();\n    const log = (keyStack: string[]) => {\n        accessSet.add(keyStack.join(\".\"));\n    };\n    const innerProxy = <T extends object>(object: T, keyStack: string[] = []): T => {\n        return new Proxy(object, {\n            get(target: T, key: PropertyKey, receiver: any): any {\n                const childTarget = Reflect.get(target, key, receiver);\n                // Avoid Proxy Error like follows\n                // Can not proxy Set, Map, TypedArray ...\n                // Just Proxy Object Literal(plain object)\n                // TypeError: Method get TypedArray.prototype.length called on incompatible receiver [object Object]\n                // https://stackoverflow.com/questions/43927933/why-is-set-incompatible-with-proxy\n                const isObjectLiteral = isPlainObject(childTarget);\n                const currentKey = String(key);\n                const currentKeyStack = keyStack.concat(currentKey);\n                log(currentKeyStack);\n                if (childTarget !== null && isObjectLiteral) {\n                    return innerProxy(childTarget, currentKeyStack);\n                }\n                return childTarget;\n            }\n        });\n    };\n    return {\n        proxyObject: innerProxy(object),\n        accessSet\n    };\n};\n"],"names":["class2type","toString","getProto","Object","getPrototypeOf","hasOwn","hasOwnProperty","fnToString","ObjectFunctionString","call","createProxy","object","accessSet","Set","innerProxy","keyStack","Proxy","get","target","key","receiver","childTarget","Reflect","isObjectLiteral","obj","proto","Ctor","constructor","isPlainObject","currentKey","String","currentKeyStack","concat","add","join","log","proxyObject"],"mappings":"AAAA,MAAMA,EAAa,GACbC,EAAWD,EAAWC,SACtBC,EAAWC,OAAOC,eAClBC,EAASL,EAAWM,eACpBC,EAAaF,EAAOJ,SACpBO,EAAuBD,EAAWE,KAAKN,QCChCO,EAAiCC,IAC1C,MAAMC,EAAY,IAAIC,IAIhBC,EAAa,CAAmBH,EAAWI,EAAqB,SACvDC,MAAML,EAAQ,CACrBM,IAAIC,EAAWC,EAAkBC,GAC7B,MAAMC,EAAcC,QAAQL,IAAIC,EAAQC,EAAKC,GAMvCG,WDRQC,GAG1B,IAAKA,GAA8B,oBAAvBvB,EAASQ,KAAKe,GACtB,SAGJ,MAAMC,EAAQvB,EAASsB,GAGvB,IAAKC,EACD,SAIJ,MAAMC,EAAOrB,EAAOI,KAAKgB,EAAO,gBAAkBA,EAAME,YACxD,MAAuB,mBAATD,GAAuBnB,EAAWE,KAAKiB,KAAUlB,ECR3BoB,CAAcP,GAChCQ,EAAaC,OAAOX,GACpBY,EAAkBhB,EAASiB,OAAOH,GAExC,MAhBCd,CAAAA,IACTH,EAAUqB,IAAIlB,EAASmB,KAAK,OAcpBC,CAAIJ,GACgB,OAAhBV,GAAwBE,EACjBT,EAAWO,EAAaU,GAE5BV,KAInB,MAAO,CACHe,YAAatB,EAAWH,GACxBC,UAAAA"}